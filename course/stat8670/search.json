[
  {
    "objectID": "02-optimization.html",
    "href": "02-optimization.html",
    "title": "2  Numerical Approaches and Optimization",
    "section": "",
    "text": "2.1 Theory versus Computation\nThe optimization plays an important role in statistical computing, especially in the context of maximum likelihood estimation (MLE) and other statistical inference methods. This chapter will cover various optimization techniques used in statistical computing.\nThere is a general principle that will be repeated in this chapter that Kenneth Lange calls optimization transfer in his 1999 paper. The basic idea applies to the problem of maximizing a function \\(f\\).\nNote 1: steps 2&3 are repeated until convergence.\nNote 2: maximizing \\(f\\) is equivalent to minimizing \\(-f\\).\nNote 3: the surrogate function \\(g\\) should be chosen such that it is easier to optimize than \\(f\\).\nFor instance, for a linear regression \\[\\begin{equation}\n  y = X\\boldsymbol{\\beta} + \\varepsilon. \\label{eq:linmod}\n\\end{equation}\\]\nFrom regression class, we know that the (ordinary) least-squares estimation (OLE) for \\(\\boldsymbol{\\beta}\\) is given by \\(\\hat{\\boldsymbol{\\beta}}=(X^\\top X)^{-1} X^\\top y\\). It is convenient as the solution is in the closed-form! However, in the most case, the closed-form solutions will not be available.\nFor GLMs or non-linear regression, we need to do this iterativelly!\nOne confusing aspect of statistical computing is that often there is a disconnect between what is printed in a statistical computing textbook and what should be implemented on the computer.\nSome potential issues includ:\nA &lt;- matrix(\n  c(1, 2, 3,\n    4, 5, 6,\n    7, 8, 9),\n  nrow = 3, ncol = 3, byrow = TRUE)\nB &lt;- A\nB[3, 3] &lt;- B[3, 3] + 1E-5\n\nqr(A)$rank\n\n[1] 2\n\nqr(B)$rank\n\n[1] 3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  },
  {
    "objectID": "02-optimization.html#theory-versus-computation",
    "href": "02-optimization.html#theory-versus-computation",
    "title": "2  Numerical Approaches and Optimization",
    "section": "",
    "text": "In textbooks, simpler to present solutions as convenient mathematical formulas whenever possible, in order to communicate basic ideas and to provide some insight.\n\nHowever, directly translating these formulas into computer code is usually not advisable because there are many problematic aspects of computers that are simply not relevant when writing things down on paper.\n\n\n\n\nMemory overflow: The computer has a limited amount of memory, and it is possible to run out of memory when working with large datasets or complex models.\nNumerical Precision: Sometimes, due to the cut precision of floating-point arithmetic, calculations that are mathematically equivalent can yield different results on a computer.\n\nExample 1: round \\(1/3\\) to two decimal places, we get \\(0.33\\). Then, \\(3 \\cdot (1/3)\\) is exactly \\(1\\), but \\(3 \\cdot 0.33\\) is \\(0.99\\).\nExample 2: \\(1 - 0.99999999\\) is \\(0.00000001\\) (=1E-8), but if we round \\(0.99999999\\) to two decimal places, we get \\(1.00\\), and then \\(1 - 1.00\\) is \\(0\\). If we round \\(0.00000001\\) to two decimal places, we get \\(0.00\\).\nExample 3: \\(\\pi\\)\n\n(Lienar) Dependence: The detection of linear dependence in matrix computations is influenced by machine precision. Since computers operate with finite precision, situations often arise where true linear dependence exists, but the computer cannot distinguish it from independence.\n\nExample: Consider the matrix \\[\nA = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9 \\\\\n\\end{pmatrix}\n\\] The 3rd column is a linear combination of the first two columns (i.e., col3 = col1 + col2). However, due to machine precision limitations, the computer might not recognize this exact linear dependence, leading to numerical instability in computations involving this matrix. With a small distortion, we have \\[\nB = \\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9 + 10^{-5} \\\\\n\\end{pmatrix}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  },
  {
    "objectID": "02-optimization.html#matrix-inversion",
    "href": "02-optimization.html#matrix-inversion",
    "title": "2  Numerical Approaches and Optimization",
    "section": "2.2 Matrix Inversion",
    "text": "2.2 Matrix Inversion\nIn many statistical analyses, such as linear regression and specify the distribution (such as normal distribution), matrix inversion plays a central role.\n\n2.2.1 Example 1: Normal distribution\nWe know that, a normal density with the parameters mean \\(\\mu\\) and standard deviation \\(\\sigma\\) is \\[\nf\\left(x \\mid \\mu, \\sigma^2\\right)=\\frac{1}{\\sqrt{2 \\pi} \\sigma} \\exp\\left\\{-\\frac{1}{2 \\sigma^2}(x-\\mu)^2\\right\\}\n\\] or we may work on the multivariate normal distribution case which is a bit more involved.\n\n\\(\\boldsymbol{X} = (X1,\\dots, X_d)\\) is said to be a multivariate normal distribution if and only if it is a linear comibnation of independent and identically distributed standard normals: \\[\n\\boldsymbol{X} = \\boldsymbol{CZ} + \\mu,\\quad \\boldsymbol{Z}=(Z_1,\\dots,Z_d),\\quad Z_i \\stackrel{iid}{\\sim} N(0,1).\n\\]\n\nThe property of the multivariate normal are:\n\nmean vector: \\(E(\\boldsymbol{X}) = \\mu\\)\nvariance: \\(Var(\\boldsymbol{X}) = \\boldsymbol{CZC}^\\top = \\boldsymbol{C} var(\\boldsymbol{Z})\\boldsymbol{C}^\\top:=  \\boldsymbol{\\Sigma}\\)\n\nNotation: \\(\\boldsymbol{X} \\sim N(\\mu, \\boldsymbol{\\Sigma})\\).\nPDF: \\[\nf(\\boldsymbol{x} \\mid \\mu, \\Sigma)=(2 \\pi)^{-d / 2} \\cdot \\exp \\left\\{-\\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^{\\prime} \\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})-\\frac{1}{2} \\log |\\boldsymbol{\\Sigma}|\\right\\}.\n\\] Some of the potential ways to do this is to take logarithm of the PDF (Think about why).\n\n\n2.2.2 Example 2: Linear regression\nRecall the linear regression model . The OLE for \\(\\boldsymbol{\\beta}\\) is given by \\(\\hat{\\boldsymbol{\\beta}}=(X^\\top X)^{-1} X^\\top y\\).\nWe can solve this using the R command\nbeta_hat &lt;- solve(t(X) %*% X) %*% t(X) %*% y\nwhere solve() is the R function for matrix inversion. However, it is not a desired way (think about why).\nA better way is to go back to the formula, and look at \\[\nX^\\top X\\boldsymbol{\\beta}= X^\\top y,\n\\] and solve this using the R command\nsolve( crossprod(X), crossprod(X, y) ) \n# this is the same as \n# solve(t(X) %*% X, t(X) %*% y)\nHere, we avoid explicitly calculating the inverse of \\(X^\\top X\\). Instead, we use gaussian elimination to solve the system of equations, which is generally more numerically stable and efficient.\n\n2.2.2.1 Speed comparison\nset.seed(2025-09-03)\nX &lt;- matrix(rnorm(5000 * 100), 5000, 100)\ny &lt;- rnorm(5000)\nlibrary(microbenchmark)\nmicrobenchmark(solve(t(X) %*% X) %*% t(X) %*% y)\nUnit: milliseconds\n                             expr      min       lq\n solve(t(X) %*% X) %*% t(X) %*% y 28.83505 30.16593\n     mean   median       uq      max neval\n 31.96782 30.79489 32.63315 111.0151   100\nWarning message:\nIn microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y) :\n  less accurate nanosecond times to avoid potential integer overflows\nmicrobenchmark(solve(t(X) %*% X) %*% t(X) %*% y,\n               solve(crossprod(X), crossprod(X, y)))\nUnit: milliseconds\n                                 expr      min       lq\n     solve(t(X) %*% X) %*% t(X) %*% y 28.90135 30.11608\n solve(crossprod(X), crossprod(X, y)) 25.05859 25.27480\n     mean   median       uq      max neval\n 31.78686 31.38513 32.66482 53.03354   100\n 26.15771 25.81678 26.89188 29.12045   100\n\n\n\n2.2.3 Take home message:\nThe take home here is that the issues arise from the finite precision of computer arithmetic and the limited memory available on computers. When implementing statistical methods on a computer, it is crucial to consider these limitations and choose algorithms and implementations that are robust to numerical issues.\n\n\n2.2.4 Multi-collinearity\nThe above approach may break down when there is any multi-colinearity in the \\(\\boldsymbol{X}\\) matrix. For example, we can tack on a column to \\(\\boldsymbol{X}\\) that is very similar (but not identical) to the first column of \\(\\boldsymbol{X}\\).\n\nset.seed(7777)\nN &lt;- 3000\nK &lt;- 100\ny &lt;- rnorm(N)\nX &lt;- matrix(rnorm(N * K), N, K)\nW &lt;- cbind(X, X[, 1] + rnorm(N, sd = 1E-15))\n\nsolve(crossprod(W), crossprod(W, y))\n\nError in `solve.default()`:\n! system is computationally singular: reciprocal condition number = 1.36748e-32\nThe algorithm does not work because the cross product matrix \\(W^\\top W\\) is singular. In practice, matrices like these can come up a lot in data analysis and it would be useful to have a way to deal with it automatically.\nR takes a different approach to solving for the unknown coefficients in a linear model. R uses the QR decomposition, which is not as fast, but has the added benefit of being able to automatically detect and handle colinear columns in the matrix.\nHere, we use the fact that X can be decomposed as \\(\\boldsymbol{X}=QR\\), where \\(Q\\) is an orthonormal matrix and \\(R\\) is an upper triangular matrix. Given that, we can rewrite \\(X^\\top X \\boldsymbol{\\beta}= X^\\top y\\) as \\[\\begin{align*}\nR^\\top Q^\\top Q R \\boldsymbol{\\beta}&= R^\\top Q^\\top y\\\\\nR^\\top I R \\boldsymbol{\\beta}&= R^\\top Q^\\top y\\\\\nR^\\top R \\boldsymbol{\\beta}&= R^\\top Q^\\top y,\n\\end{align*}\\] this leads to \\(R\\boldsymbol{\\beta}= Q^\\top y\\). Now we can perform the Gaussian elimination to do it. Because \\(R\\) is an upper triangular matrix, the computational speed is much faster. Here, we avoid to compute the cross product \\(X^\\top X\\), which is numerical unstable if it is not standardized properly\nWe can see in R code that even with our singular matrix \\(W\\) above, the QR decomposition continues without error.\n\nQw &lt;- qr(W)\nstr(Qw)\n\nList of 4\n $ qr   : num [1:3000, 1:101] 54.43933 0.00123 -0.02004 -0.00671 -0.00178 ...\n $ rank : int 100\n $ qraux: num [1:101] 1.01 1.01 1.01 1 1 ...\n $ pivot: int [1:101] 1 2 3 4 5 6 7 8 9 10 ...\n - attr(*, \"class\")= chr \"qr\"\n\n\nNote that the output of qr() computes the rank of \\(W\\) to be 100, not 101 as the last column is collinear to the 1st column. From there, we can get \\(\\hat{\\boldsymbol{\\beta}}\\) if we want using qr.coef(),\n\nbetahat &lt;- qr.coef(Qw, y)\nhead(betahat, 3)\n\n[1]  0.024314718  0.000916951 -0.005980588\n\ntail(betahat, 3)\n\n[1]  0.01545039 -0.01010440          NA\n\n\nQ: Why there is an NA?\n\n\n2.2.5 Trade-off\nThere isn’t always elegance and flourish. When we take the robust approach, we accept that it comes at a cost.\n\nlibrary(ggplot2)\nlibrary(microbenchmark)\nm &lt;- microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y,\n                    solve(crossprod(X), crossprod(X, y)),\n                    qr.coef(qr(X), y))\n\nWarning in microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y, solve(crossprod(X),\n: less accurate nanosecond times to avoid potential integer overflows\n\nautoplot(m)\n\n\n\n\n\n\n\n\nCompared with the approaches discussed above, this method performs similarly to the naive approach but is much more stable and reliable.\nIn practice, we rarely call functions such as qr() or qr.coef() directly, since higher-level functions like lm() handle these computations automatically. However, in certain specialized and performance-critical settings, it can be advantageous to use alternative matrix decompositions to compute regression coefficients, especially when the computation must be repeated many times in a loop (i.e., Vectorization)\n\n\n2.2.6 Multivariate Normal revisit\nComputing the multivariate normal (MVN) density is a common task, for example, when fitting spatial models or Gaussian process models. Because maximum likelihood estimation(MLE) and likelihood ratio tests (LRT) often require evaluating the likelihood many times, efficiency is crucial.\nAfter taking the log of the MVN density, we have\n\\[\n\\ell(\\boldsymbol{x}\\mid \\boldsymbol{\\mu},\\Sigma) := \\log \\left\\{ f(\\boldsymbol{x}\\mid \\boldsymbol{\\mu},\\Sigma) \\right\\}\n= -\\frac{d}{2}\\log(2\\pi) - \\frac{1}{2}\\log|\\Sigma| - \\frac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^\\top \\Sigma^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu}).\n\\] On the right hand side, the first term is a constant, the second term is linear, and the last term is quadratic, which requires much more computational power.\n\n2.2.6.1 A Naive Implementation\nWe first center the data \\(\\boldsymbol{z}:=\\boldsymbol{x}- \\mu\\). Then we have \\(\\boldsymbol{z}^\\top \\Sigma^{-1} \\boldsymbol{z}\\). This simiplified the question for a bit.\nHere, much like the linear regression example above, the key bottleneck is the inversion of the \\(p\\)-dimensional covariance matrix \\(\\Sigma\\). If we take \\(\\boldsymbol{z}\\) to be a \\(p\\times 1\\) column vector, then a literal translation of the mathematics into R code might look something like this,\nt(z) %*% solve(Sigma) %*% z\nTo illustrate, let’s simulate some data and compute the quadratic form the naive way:\n\nset.seed(2025-09-03)\n\n# Generate data\nz &lt;- matrix(rnorm(200 * 100), 200, 100)\nS &lt;- cov(z)\n\n# Naive quadratic form\nquad.naive &lt;- function(z, S) {\n  Sinv &lt;- solve(S)\n  rowSums((z %*% Sinv) * z)\n}\n\nlibrary(dplyr)\nquad.naive(z, S) %&gt;% summary()\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  70.67   93.61   99.94  100.54  107.31  126.73 \n\n\n\n\n2.2.6.2 A Better Way: Cholesky Decomposition\nBecause the covariance matrix is symmetric and positive definite, we can exploit its Cholesky decomposition. That is, we write \\(\\Sigma = R^\\top R\\), where \\(R\\) is a upper triangular matrix. Then, \\[\n\\boldsymbol{z}^\\top \\Sigma^{-1} \\boldsymbol{z}= \\boldsymbol{z}^\\top (R^\\top R)^{-1} \\boldsymbol{z}= \\boldsymbol{z}^\\top R^{-1}R^{-\\top} \\boldsymbol{z}= (R^{-\\top}\\boldsymbol{z})^\\top (R^{-\\top} \\boldsymbol{z}) := \\boldsymbol{v}^\\top \\boldsymbol{v}.\n\\] Note that \\(\\boldsymbol{v}\\in \\mathbb R^p\\) is the solution to the linear system \\(R^\\top \\boldsymbol{v}= \\boldsymbol{z}\\). Because \\(R\\) is upper triangular, we can solve this system efficiently using back substitution. Also, we can solve this without doing the inversion.\nOnce we have \\(\\boldsymbol{v}\\) we can compute its quadratic form \\(\\boldsymbol{v}^\\top \\boldsymbol{v}\\) by the crossprod() function.\n\nquad.chol &lt;- function(z, S) {\n  R &lt;- chol(S)\n  v &lt;- backsolve(R, t(z), transpose = TRUE)\n  colSums(v * v)\n}\n\nquad.chol(z, S) %&gt;% summary()\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  70.67   93.61   99.94  100.54  107.31  126.73 \n\n\n\n\n2.2.6.3 By product\nAnother benefit of the Cholesky decomposition is that it gives us a simple way to compute the log-determinant of \\(\\Sigma\\). The log-determinant of \\(\\Sigma\\) is simply two times the sum of the log of the diagonal elements of R. (Why?)\n\n\n2.2.6.4 Performance comparison\n\nlibrary(microbenchmark)\nlibrary(ggplot2)\nm2 &lt;- microbenchmark(\n  naive = quad.naive(z, S),\n  chol  = quad.chol(z, S)\n)\nautoplot(m2)\n\n\n\n\n\n\n\n\nQ: Why one is faster than the other?\n\n\n2.2.6.5 Take home message 2\nThe naive algorithm simply inverts the covariance matrix. The Cholesky-based approach, on the other hand, exploits the fact that covariance matrices are symmetric and positive definite. This results in an implementation that is both faster and numerically more stable—exactly the kind of optimization that makes a difference in real-world statistical computing.\nThus, a knowledge of statistics and numerical analysis can often lead to better algorithms, often invaluable!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  },
  {
    "objectID": "02-optimization.html#we-will-touch-the-concept-below-in-next-class",
    "href": "02-optimization.html#we-will-touch-the-concept-below-in-next-class",
    "title": "2  Numerical Approaches and Optimization",
    "section": "2.3 We will touch the concept below in next class",
    "text": "2.3 We will touch the concept below in next class",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  },
  {
    "objectID": "02-optimization.html#type-of-optimization-algorithms",
    "href": "02-optimization.html#type-of-optimization-algorithms",
    "title": "2  Numerical Approaches and Optimization",
    "section": "2.4 Type of Optimization Algorithms",
    "text": "2.4 Type of Optimization Algorithms\nThere are in general two types of the optimization algorithms: (1). deterministic and (2). metaheuristic. Deterministic and metaheuristic algorithms represent two distinct paradigms in optimization. Deterministic methods, such as gradient descent, produce the same solution for a given input and follow a predictable path toward an optimum. In contrast, metaheuristic approaches—like genetic algorithms—incorporate randomness and do not guarantee the best possible solution. However, they are often more effective at avoiding local optima and exploring complex search spaces.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  },
  {
    "objectID": "02-optimization.html#heuristic-algorithms",
    "href": "02-optimization.html#heuristic-algorithms",
    "title": "2  Numerical Approaches and Optimization",
    "section": "2.5 Heuristic Algorithms",
    "text": "2.5 Heuristic Algorithms\nMany of the heuristic algorithms are inspired by the nature, such as the genetic algorithm (GA) and particle swarm optimization (PSO). These algorithms are often used for complex optimization problems where traditional methods may struggle to find a solution. Some of the popular heuristic algorithms include:\n\nGenetic Algorithm (GA)\nParticle Swarm Optimization (PSO)\nSimulated Annealing (SA)\nAnt Colony Optimization (ACO)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  },
  {
    "objectID": "02-optimization.html#deterministic-algorithms",
    "href": "02-optimization.html#deterministic-algorithms",
    "title": "2  Numerical Approaches and Optimization",
    "section": "2.6 Deterministic Algorithms",
    "text": "2.6 Deterministic Algorithms\nNumerical approximation, what you learned in the mathematical optimization course. Some of the algorithms include:\n\nGradient Descent\nNewton’s Method\nConjugate Gradient Method\nQuasi-Newton Methods (e.g., BFGS)\nInterior Point Methods\n\nThey often reply on the KKT conditions.\n\n2.6.1 In R\noptim() function, nlm() function or mle() function.\n\n\n2.6.2 EM Algorithm\nThe EM (Expectation–Maximization) algorithm is an optimization method that is often applied to find maximum likelihood estimates when data is incomplete or has missing values. It iteratively refines estimates of parameters by alternating between (1) expectation step (E-step) and (2) maximization step (M-step).\n\n\n\n\n\n\nTip with Title\n\n\n\nFor example, consider the function \\(f(x) = x^2\\).\n\n\n\nExample\n\\[\nf(x) = x^2\n\\]\n\n\nExample Theorem\n\n\nExamples are borrowed from the following sources:\n\nPeng, R.D. Advanced Statistical Computing.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Numerical Approaches and Optimization</span>"
    ]
  }
]